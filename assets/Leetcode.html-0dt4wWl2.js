const n=JSON.parse('{"key":"v-b9d4bff0","path":"/contents/Leetcode.html","title":"Leetcode","lang":"zh-CN","frontmatter":{"article":true,"title":"Leetcode","icon":"read","description":"思路 双指针与链表 合并有序链表 拆分链表 直接使用两个节点遍历，按条件分别生成两个链表，最后合并起来，注意中途要拆分原有的关联 合并k个有序链表 类似合并2个有序链表，但这里使用到了优先级队列，快速找到最小的节点。优先级队列属于单独的数据结构，需要了解 单链表的倒数第 k 个节点 两个指针，第一个先走k步，再将两个指针一起走，最后第一个指针到达尾部时，第二个刚好走了n-k步 类似的还有删除倒数第k个节点 链表中点 直接使用快慢指针 判断是否包含环 使用快慢指针，如果两个指针相交则表示包含环，相交后任意一个节点回到头，然后相同速度往前走，再次相交则为相交的起点。 两个链表是否相交 两个指针分别依次走两个链表，最后看是否相交。 类似的，也可以将两个链表首位相连，判断是否存在环 双指针与数组 快慢指针 原地修改数组 删除排序数组中的重复元素等，直接使用快慢指针，发现一个与慢指针不同的时，将慢指针设置为新值，这样从0到慢指针就都为不同的元素了。 左右指针 二分查找 二分查找是一种左右指针的应用 两数之和，但是是有序数组 一左一右指针，相加和，如果结果大了则右边往左，结果小了则左边往右，如果指针相遇则没有结果 翻转数组 一左一右互换即可 判断回文 一左一右判断是否相等，一直持续到指针相遇。 判断最长回文子串，也就是从中间开始向两边试图查找回文串，注意中心可能是当前字符，也可能是当前和接下来的字符 动态规划法 核心思想在于找到分解问题，将问题降级再重新组装 斐波那契数列：分解为前面2个数之和 最长递增自学：当前序列是否为递增，新增下一个值是否依然为递增 回溯法 代码框架","head":[["meta",{"property":"og:url","content":"https://notes-page-mu.vercel.app/contents/Leetcode.html"}],["meta",{"property":"og:site_name","content":"我的笔记"}],["meta",{"property":"og:title","content":"Leetcode"}],["meta",{"property":"og:description","content":"思路 双指针与链表 合并有序链表 拆分链表 直接使用两个节点遍历，按条件分别生成两个链表，最后合并起来，注意中途要拆分原有的关联 合并k个有序链表 类似合并2个有序链表，但这里使用到了优先级队列，快速找到最小的节点。优先级队列属于单独的数据结构，需要了解 单链表的倒数第 k 个节点 两个指针，第一个先走k步，再将两个指针一起走，最后第一个指针到达尾部时，第二个刚好走了n-k步 类似的还有删除倒数第k个节点 链表中点 直接使用快慢指针 判断是否包含环 使用快慢指针，如果两个指针相交则表示包含环，相交后任意一个节点回到头，然后相同速度往前走，再次相交则为相交的起点。 两个链表是否相交 两个指针分别依次走两个链表，最后看是否相交。 类似的，也可以将两个链表首位相连，判断是否存在环 双指针与数组 快慢指针 原地修改数组 删除排序数组中的重复元素等，直接使用快慢指针，发现一个与慢指针不同的时，将慢指针设置为新值，这样从0到慢指针就都为不同的元素了。 左右指针 二分查找 二分查找是一种左右指针的应用 两数之和，但是是有序数组 一左一右指针，相加和，如果结果大了则右边往左，结果小了则左边往右，如果指针相遇则没有结果 翻转数组 一左一右互换即可 判断回文 一左一右判断是否相等，一直持续到指针相遇。 判断最长回文子串，也就是从中间开始向两边试图查找回文串，注意中心可能是当前字符，也可能是当前和接下来的字符 动态规划法 核心思想在于找到分解问题，将问题降级再重新组装 斐波那契数列：分解为前面2个数之和 最长递增自学：当前序列是否为递增，新增下一个值是否依然为递增 回溯法 代码框架"}],["meta",{"property":"og:type","content":"article"}],["meta",{"property":"og:locale","content":"zh-CN"}],["meta",{"property":"og:updated_time","content":"2023-12-13T09:38:57.000Z"}],["meta",{"property":"article:author","content":"zihan"}],["meta",{"property":"article:modified_time","content":"2023-12-13T09:38:57.000Z"}],["script",{"type":"application/ld+json"},"{\\"@context\\":\\"https://schema.org\\",\\"@type\\":\\"Article\\",\\"headline\\":\\"Leetcode\\",\\"image\\":[\\"\\"],\\"dateModified\\":\\"2023-12-13T09:38:57.000Z\\",\\"author\\":[{\\"@type\\":\\"Person\\",\\"name\\":\\"zihan\\",\\"url\\":\\"https://github.com/zilan920/notes\\"}]}"]]},"headers":[{"level":2,"title":"思路","slug":"思路","link":"#思路","children":[]},{"level":2,"title":"核心思路","slug":"核心思路","link":"#核心思路","children":[{"level":3,"title":"基础数据结构","slug":"基础数据结构","link":"#基础数据结构","children":[]},{"level":3,"title":"进阶数据结构","slug":"进阶数据结构","link":"#进阶数据结构","children":[]},{"level":3,"title":"暴力算法","slug":"暴力算法","link":"#暴力算法","children":[]},{"level":3,"title":"动态规划","slug":"动态规划","link":"#动态规划","children":[]}]}],"git":{"createdTime":1702454816000,"updatedTime":1702460337000,"contributors":[{"name":"zihan.fang","email":"zihan.fang@bitdeer.com","commits":4}]},"readingTime":{"minutes":4.85,"words":1454},"filePathRelative":"contents/Leetcode.md","localizedDate":"2023年12月13日","excerpt":"<h2> 思路</h2>\\n<ul>\\n<li>\\n<p>双指针与链表</p>\\n<ul>\\n<li>\\n<p>合并有序链表</p>\\n</li>\\n<li>\\n<p>拆分链表</p>\\n<p>直接使用两个节点遍历，按条件分别生成两个链表，最后合并起来，注意中途要拆分原有的关联</p>\\n</li>\\n<li>\\n<p>合并k个有序链表</p>\\n<p>类似合并2个有序链表，但这里使用到了优先级队列，快速找到最小的节点。优先级队列属于单独的数据结构，需要了解</p>\\n</li>\\n<li>\\n<p>单链表的倒数第 k 个节点</p>\\n<p>两个指针，第一个先走k步，再将两个指针一起走，最后第一个指针到达尾部时，第二个刚好走了n-k步<br>\\n类似的还有删除倒数第k个节点</p>\\n</li>\\n<li>\\n<p>链表中点</p>\\n<p>直接使用快慢指针</p>\\n</li>\\n<li>\\n<p>判断是否包含环</p>\\n<p>使用快慢指针，如果两个指针相交则表示包含环，相交后任意一个节点回到头，然后相同速度往前走，再次相交则为相交的起点。</p>\\n</li>\\n<li>\\n<p>两个链表是否相交</p>\\n<p>两个指针分别依次走两个链表，最后看是否相交。<br>\\n类似的，也可以将两个链表首位相连，判断是否存在环</p>\\n</li>\\n</ul>\\n</li>\\n<li>\\n<p>双指针与数组</p>\\n<ul>\\n<li>快慢指针\\n<ul>\\n<li>\\n<p>原地修改数组</p>\\n<p>删除排序数组中的重复元素等，直接使用快慢指针，发现一个与慢指针不同的时，将慢指针设置为新值，这样从0到慢指针就都为不同的元素了。</p>\\n</li>\\n</ul>\\n</li>\\n<li>左右指针\\n<ul>\\n<li>\\n<p>二分查找</p>\\n<p>二分查找是一种左右指针的应用</p>\\n</li>\\n<li>\\n<p>两数之和，但是是有序数组</p>\\n<p>一左一右指针，相加和，如果结果大了则右边往左，结果小了则左边往右，如果指针相遇则没有结果</p>\\n</li>\\n<li>\\n<p>翻转数组</p>\\n<p>一左一右互换即可</p>\\n</li>\\n<li>\\n<p>判断回文</p>\\n<p>一左一右判断是否相等，一直持续到指针相遇。<br>\\n判断最长回文子串，也就是从中间开始向两边试图查找回文串，注意中心可能是当前字符，也可能是当前和接下来的字符</p>\\n</li>\\n</ul>\\n</li>\\n</ul>\\n</li>\\n<li>\\n<p>动态规划法</p>\\n<p>核心思想在于找到分解问题，将问题降级再重新组装<br>\\n斐波那契数列：分解为前面2个数之和<br>\\n最长递增自学：当前序列是否为递增，新增下一个值是否依然为递增</p>\\n</li>\\n<li>\\n<p>回溯法</p>\\n<p>代码框架</p>\\n</li>\\n</ul>","autoDesc":true}');export{n as data};
