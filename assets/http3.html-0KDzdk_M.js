import{_ as t}from"./plugin-vue_export-helper-x3n3nnut.js";import{o as T,c as e,e as d}from"./app-vg2OS4np.js";const i="/assets/d-pmjqbe3t.png",a="/assets/tls-SDkl8cTA.png",r="/assets/keep-live-and-pipeline-uNc5LoII.png",p="/assets/multiplexing-qI5D-Zfg.png",l="/assets/encoder-NeezIh1D.png",s="/assets/quic-TDI_crYG.png",n="/assets/http1-3-Fdq0a5VP.png",h={},o=d('<p><code>几年前做了关于HTTP3的分享，为了避免遗忘，将内容整理出来并完善</code></p><h5 id="什么是rtt" tabindex="-1"><a class="header-anchor" href="#什么是rtt" aria-hidden="true">#</a> 什么是RTT</h5><p>RTT是Round Trip Time的缩写，通俗地说，就是通信一来一回的时间。我们可以使用RTT快速评估协议所需要的传输时间。</p><h5 id="一次http循环的时间" tabindex="-1"><a class="header-anchor" href="#一次http循环的时间" aria-hidden="true">#</a> 一次HTTP循环的时间</h5><p>那么一次TCP建立连接时的握手，一共需要 1.5RTT<br><img src="'+i+'" alt="TCP" loading="lazy"></p><p>而对于一个HTTP请求&amp;响应，加上HTTP Request&amp;Response，算作一个1RTT。</p><p>那么基于TCP的的HTTP的消耗时间总和，就是 1.5RTT + 1RTT = 2.5RTT</p><h5 id="关于tls下的rtt影响" tabindex="-1"><a class="header-anchor" href="#关于tls下的rtt影响" aria-hidden="true">#</a> 关于TLS下的RTT影响</h5><p>在TLS下，一个HTTP循环需要多少RTT？</p><p>让我们先看一下啊TLS1.2的过程</p><ul><li>clientHello</li><li>ServerHello, Ask for certificate</li><li>验证后发送Client Key Exchange, Change Cipher Spec</li><li>服务端Change Cipher Spec</li></ul><p>因此TLS1.2 握手时，总共需要2RTT的时间</p><p>对于非首次连接，可以选择启用会话重用(Session Resumption)，可以缩小时间到1RTT</p><p>因而对于采用tls1.2的HTTP连接，需要 1.5 RTT (TCP)+ 1 RTT (HTTP Request &amp; Response) + 2RTT(TLS) = 4.5RTT 时间</p><ul><li>TLS1.3</li></ul><p>TLS1.3 引入了TLS1.2 会话重用机制的升级：密钥协商机制 - PSK (pre shared key)，使得消耗时间变为1 RTT</p><p>同样，对于非首次握手，可以支持 增加Early Data ，直接在握手阶段发送数据，相当于0-RTT （发送数据不需要额外RTT，即为0RTT）</p><p>因而一个HTTP通讯，需要 1.5 RTT(TCP)+ 1 RTT(HTTP Request &amp; Response) + 1RTT(TLS) = 3.5RTT 时间</p><p><img src="'+a+'" alt="TLS" loading="lazy"></p><h5 id="关于http的影响" tabindex="-1"><a class="header-anchor" href="#关于http的影响" aria-hidden="true">#</a> 关于HTTP的影响</h5><ul><li>HTTP1.x支持长连接 keep-live， pipeline</li></ul><p>在HTTP1.x中，每个连接相互独立，因而每一个HTTP请求都需要3.5RTT。最终结果视请求量正比增长。开启keep-live 后，可以为后续的连接复用已开启的TCP，从而减少后续所需时间。</p><p>长连接带来的问题：但是在同一个 TCP 连接里面，所有的数据通信是按次序进行的。服务器只有处理完一个回应，才会进行下一个回应。要是前面的回应特别慢，后面就会有许多请求排队等着。这称为&quot;队头堵塞&quot;（Head-of-line blocking）。</p><p>这也带来pipeline技术，在相应到达之前，可以将多条请求放入队列，当第一条请求发往服务器的时候，第二第三条请求也可以开始发送了。<br><img src="'+r+'" alt="keep-live-and-pipieline" loading="lazy"></p><ul><li>HTTP/2 多路复用，头信息压缩</li></ul><p>HTTP2 带来了多路复用，允许同时通过单一的 HTTP/2 连接发起多重的请求-响应消息。即连接共享，即每一个 request 都是是用作连接共享机制的。一个 request 对应一个 id，这样一个连接上可以有多个 request，每个连接的 request 可以随机的混杂在一起，接收方可以根据 request 的 id 将 request 再归属到各自不同的服务端请求里面</p><p>复用TLS连接，第一个之后的每一个HTTP可以减少1.5RTT + 2RTT = 3.5 RTT时间<br><img src="'+p+'" alt="multiplexing" loading="lazy"></p><p>在HTTP1.x中， header常常带有大量信息，而且每次都要重复发送，HTTP/2 使用 encoder 来减少需要传输的 header 大小，通讯双方各自cache 一份 header fields 表，既避免了重复 header 的传输，又减小了需要传输的大小。<br><img src="'+l+'" alt="encoder" loading="lazy"></p><h5 id="quic" tabindex="-1"><a class="header-anchor" href="#quic" aria-hidden="true">#</a> QUIC !!</h5><p>Quic 全称 quick udp internet connection，和英文 quick 谐音，简称“快”）是由 google 提出的使用 udp 进行多路并发传输的协议。</p><ul><li><p>强大优势</p><ul><li>链接耗时更短，非首次连接支持0RTT</li><li>拥塞控制更出色</li><li>更好的多路复用</li><li>前向纠错特性</li><li>链接迁移特性<br><img src="'+s+'" alt="quic" loading="lazy"></li></ul></li><li><p>华丽转身</p></li></ul><p>2018年 HTTP Over QUIC 更名 HTTP/3<br><img src="'+n+'" alt="http1-3" loading="lazy"></p><h5 id="对比" tabindex="-1"><a class="header-anchor" href="#对比" aria-hidden="true">#</a> 对比</h5><table><thead><tr><th></th><th>HTTP</th><th>HTTPS 1.2 首次连接</th><th>HTTPS 1.2 连接复用</th><th>HTTPS 1.3 首次连接</th><th>HTTPS 1.3 连接复用</th><th>HTTP over QUIC首次连接</th><th>HTTP over QUIC 连接复用</th></tr></thead><tbody><tr><td>TCP握手</td><td>1.5RTT</td><td>1.5RTT</td><td>0 RTT</td><td>1.5RTT</td><td>0 RTT</td><td>-</td><td>-</td></tr><tr><td>TLS握手</td><td>-</td><td>2RTT</td><td>1RTT</td><td>1RTT</td><td>0RTT</td><td>-</td><td>-</td></tr><tr><td>QUIC握手</td><td>-</td><td>-</td><td>-</td><td>-</td><td>-</td><td>1RTT</td><td>0RTT</td></tr><tr><td>HTTP请求&amp;响应</td><td>1RTT</td><td>1RTT</td><td>1RTT</td><td>1RTT</td><td>1RTT</td><td>1RTT</td><td>1RTT</td></tr><tr><td>合计</td><td>2.5RTT</td><td>4.5RTT</td><td>2RTT</td><td>3.5RTT</td><td>1RTT</td><td>2RTT</td><td>1RTT</td></tr></tbody></table>',34),c=[o];function R(u,P){return T(),e("div",null,c)}const _=t(h,[["render",R],["__file","http3.html.vue"]]);export{_ as default};
