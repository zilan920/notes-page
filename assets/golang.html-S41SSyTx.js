import{_ as o}from"./plugin-vue_export-helper-x3n3nnut.js";import{r as t,o as r,c as s,a as e,b as l,d as n,e as a}from"./app-7EATgD7v.js";const c="/images/map.png",d="/images/gmp-flow.png",u="/images/go_start.png",p={},h=a(`<h2 id="go-数据结构" tabindex="-1"><a class="header-anchor" href="#go-数据结构" aria-hidden="true">#</a> go 数据结构</h2><h4 id="切片和数组" tabindex="-1"><a class="header-anchor" href="#切片和数组" aria-hidden="true">#</a> 切片和数组</h4><p>slice 的底层是数组，是对数组的封装，可以用于描述数组的一个片段，两者都可以用于描述。<br> 数组是定长的，而切片则可以动态的扩容。<br> 在存储上，数组是一片连续的内存，而 slice 实质上是一个结构体。他的结构如下：</p><div class="language-golang line-numbers-mode" data-ext="golang"><pre class="language-golang"><code>// runtime/slice.go
type slice struct {
	array unsafe.Pointer // 元素指针
	len   int // 长度
	cap   int // 容量
}
</code></pre><div class="line-numbers" aria-hidden="true"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div><ul><li>切片的扩容<br> 当我们向 slice 中追加了元素后，如果空间不足时就会引起扩容。<br> 按照以往常见的说法，在 golang1.18 版本更新之前网上大多数的文章都是这样描述 slice 的扩容策略的：</li></ul><blockquote><p>当原 slice 容量小于 1024 的时候，新 slice 容量变成原来的 2 倍；原 slice 容量超过 1024，新 slice 容量变成原来的 1.25 倍。</p></blockquote><p>在 1.18 版本更新之后，slice 的扩容策略变为了：</p><blockquote><p>当原 slice 容量(oldcap)小于 256 的时候，新 slice(newcap)容量为原来的 2 倍；原 slice 容量超过 256，新 slice 容量 newcap = oldcap+(oldcap+3*256)/4</p></blockquote><p>可以看到这是会按照版本动态变化的，扩容的实际实现位于 src/runtime/slice.go 中的 growslice 。</p>`,9),g={href:"https://github.com/golang/go/blob/dev.boringcrypto.go1.18/src/runtime/slice.go#L166",target:"_blank",rel:"noopener noreferrer"},b={href:"https://github.com/golang/go/blob/master/src/runtime/slice.go#L157",target:"_blank",rel:"noopener noreferrer"},m=e("br",null,null,-1),v=e("li",null,[e("p",null,"切片作为函数参考")],-1),_=a(`<blockquote><p>go 中的所有函数传值，都是值传递，没有引用传递。即便是传递了参数指针时，也只是基于内存地址对原有的变量进行操作。</p></blockquote><p>slice 作为函数参数传递时，都会是按照值传递复制这个数据。但由于 slice 本身会携带一个底层数组的指针，在直接操作 slice 中的变量，例如<code>slice[i] = 1</code>时，则会直接改变到原有的数组的值。</p><p>而如果我们对复制的值进行其他操作，如<code>append</code>时，则会生成一个新的 slice，此时原有的数组则不会受到影响。</p><blockquote><p>推测：当我们对一个 slice 操作时，如果没有涉及到原有 slice 的扩容，是否也会影响到？</p></blockquote><h4 id="map" tabindex="-1"><a class="header-anchor" href="#map" aria-hidden="true">#</a> map</h4><ul><li>map 的实现<br> go 中 map 的底层是一个 hmap</li></ul><div class="language-golang line-numbers-mode" data-ext="golang"><pre class="language-golang"><code>// A header for a Go map.
type hmap struct {
    // 元素个数，调用 len(map) 时，直接返回此值
	count     int
	flags     uint8
	// buckets 的对数 log_2
	B         uint8
	// overflow 的 bucket 近似数
	noverflow uint16
	// 计算 key 的哈希的时候会传入哈希函数
	hash0     uint32
    // 指向 buckets 数组，大小为 2^B
    // 如果元素个数为0，就为 nil
	buckets    unsafe.Pointer
	// 等量扩容的时候，buckets 长度和 oldbuckets 相等
	// 双倍扩容的时候，buckets 长度会是 oldbuckets 的两倍
	oldbuckets unsafe.Pointer
	// 指示扩容进度，小于此地址的 buckets 迁移完成
	nevacuate  uintptr
	extra *mapextra // optional fields
}
</code></pre><div class="line-numbers" aria-hidden="true"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div><figure><img src="`+c+`" alt="image" tabindex="0" loading="lazy"><figcaption>image</figcaption></figure><p>map 的哈希函数：在程序启动时，会检测 cpu 是否支持 aes，如果支持，则使用 aes hash，否则使用 memhash。<br> map 使用链地址法处理哈希冲突，因此当哈希碰撞发生时，map 会最终退化成一个链表。</p><ul><li><p>map 的遍历<br> map 会在遍历开始时，生成随机树种子，随机的访问其中的一个 bucket，另外由于 map 会有扩容搬迁过程，导致 map 的遍历是<strong>一定</strong>会无序的</p></li><li><p>map 的查找</p></li></ul><ol><li>写保护机制<br> 先查 hmap 的标志位 flags,如果 flags 写标志位此时是 1,说明其他协程正在写操作,直接 panic</li><li>计算 hash 值<br> key 经过哈希函数计算后,得到 64bit(64 位 CPU)<br> 10010111 | 101011101010110101010101101010101010 | 10010</li><li>找到 hash 对应的桶<br> 上面 64 位后 5(hmap 的 B 值)位定位所存放的桶<br> 如果当前正在扩容中,并且定位到旧桶数据还未完成迁移,则使用旧的桶</li><li>遍历桶查找<br> 上面 64 位前 8 位用来在 tophash 数组查找快速判断 key 是否在当前的桶中,如果不在需要去溢出桶查找</li><li>返回 key 对应的指针</li></ol><ul><li><p>map 的赋值</p></li><li><p>map 的扩容</p><ul><li><p>扩容时机：向 map 插入新 key 的时候，会进行条件检测，符合下面这 2 个条件，就会触发扩容</p><ul><li><p>超过负载 map 元素个数 &gt; 6.5（负载因子） * 桶个数</p><blockquote><pre><code>负载因子 = 哈希表存储的元素个数 / 桶个数
</code></pre></blockquote><pre><code>  		Go 官方发现：装载因子越大，填入的元素越多，空间利用率就越高，但发生哈希冲突的几率就变大。装载因子越小，入的元素越少，冲突发生的几率减小，但空间浪费也会变得更多，而且还会提高扩容操作的次数
Go 官方取了一个相对适中的值，把 Go 中的 map 的负载因子硬编码为 6.5，这就是 6.5 的选择缘由。
这意味着在 Go 语言中，当 map存储的元素个数大于或等于 6.5 * 桶个数 时，就会触发扩容行为。
</code></pre></li><li><p>溢出桶太多<br> 当桶总数&lt;2^15 时，如果溢出桶总数&gt;=桶总数，则认为溢出桶过多<br> 当桶总数&gt;2^15 时，如果溢出桶总数&gt;=2^15，则认为溢出桶过多</p></li></ul></li><li><p>扩容机制：</p><ul><li>双倍扩容：针对条件 1，新建一个 buckets 数组，新的 buckets 大小是原来的 2 倍，然后旧 buckets 数据搬迁到新的 buckets。</li><li>等量扩容：针对条件 2，并不扩大容量，buckets 数量维持不变，重新做一遍类似双倍扩容的搬迁动作，把松散的键值对重新排列一次，使得同一个 bucket 中的 key 排列地更紧密，节省空间，提高 bucket 利用率，进而保证更快的存取。</li></ul></li><li><p>渐进式扩容：<br> 插入修改删除 key 的时候，都会尝试进行搬迁桶的工作，每次都会检查 oldbucket 是否 nil，如果不是 nil 则每次搬迁 2 个桶，蚂蚁搬家一样渐进式扩容</p></li></ul></li><li><p>map 的 key 可以有哪些</p></li></ul><p>Go 语言中只要是可比较的类型都可以作为 key。除开 slice，map，functions 这几种类型，其他类型都是 OK 的。具体包括：布尔值、数字、字符串、指针、通道、接口类型、结构体、只包含上述类型的数组。<br> 任何类型都可以作为 value，包括 map 类型。</p><ul><li><p>map 的线程安全<br> map 不是一个线程安全的结构，同时读写时会直接 panic。<br> 但如果在同一个协程内进行同时读写，不会被编译器检测到，但这是危险的操作。一般可以通过<code>sync.RWMutex</code>解决<br><code>sync.Map</code>是线程安全的 map，可以用来使用，但<code>sync.Map</code>没有<code>len</code>方法，需要自己遍历实现。</p></li><li><p>map 深度相等的条件：</p></li></ul><ol><li>都为 nil</li><li>非空、长度相等，指向同一个 map 实体对象</li><li>相应的 key 指向的 value “深度”相等</li></ol><h2 id="接口-interface" tabindex="-1"><a class="header-anchor" href="#接口-interface" aria-hidden="true">#</a> 接口 Interface</h2><ul><li>接口</li></ul><p>接口支持鸭子类型<code>Duck Typing</code>。也就是编译器可以通过判断一个类型是否显式的实现了某一个接口。如果有，那么即便没有声明，也会被认为实现了该接口。</p><ul><li>接口的值接受者和指针接受者</li></ul><p>直接说结果：值接受者和指针接受者可以直接混用，这是编译器做了一些隐式转换。</p><table><thead><tr><th>-</th><th>值接收者</th><th>指针接收者</th></tr></thead><tbody><tr><td>值类型调用者</td><td>方法会使用调用者的一个副本，类似于“传值”</td><td>使用值的引用来调用方法</td></tr><tr><td>指针类型调用者</td><td>指针被解引用为值</td><td>实际上也是“传值”，方法里的操作会影响到调用者，类似于指针传参，拷贝了一份指针</td></tr></tbody></table><p>使用指针作为方法的接收者的理由：</p><ul><li>方法能够修改接收者指向的值。</li><li>避免在每次调用方法时复制该值，在值的类型为大型结构体时，这样做会更加高效。</li></ul><h2 id="channel" tabindex="-1"><a class="header-anchor" href="#channel" aria-hidden="true">#</a> Channel</h2><h2 id="go-标准库" tabindex="-1"><a class="header-anchor" href="#go-标准库" aria-hidden="true">#</a> go 标准库</h2><h2 id="调度器" tabindex="-1"><a class="header-anchor" href="#调度器" aria-hidden="true">#</a> 调度器</h2><ul><li>调度器<br> go 程序的执行由两部分组成，go Program 和 Runtime， 他们通过函数调用来实现内存灌流吗，channel 通信，goroutines 创建等。用户程序进行的系统调用都会被拦截，以此来帮助它进行调度和 GC。</li></ul><p>调度器有 3 个最基础的部分，g, m, p。</p><ul><li><p><code>g</code>表示一个 goroutine，他表示 goroutine 栈的一些字段，指示当前运行的状态</p></li><li><p><code>m</code>表示内核线程，包含正在运行的 goroutine 等字段</p></li><li><p><code>p</code>表示一个虚拟的 Processor，它维护一个处于 runnalbe 的 g 队列，m 需要获得 p 才能运行。</p></li></ul><p>当然还有一个核心结构体<code>sched</code>，它纵览全局。</p>`,30),k=e("code",null,"同步协作式调度",-1),f=e("code",null,"异步抢占式调度",-1),x={href:"https://golang.design/under-the-hood/zh-cn/part2runtime/ch06sched/preemption/",target:"_blank",rel:"noopener noreferrer"},y=a('<p>调度器的运行比较复杂，我们从我们需要知道的部分入手即可。<br><img src="'+d+'" alt="image" loading="lazy"></p><ul><li>goroutine<br> 一个 goroutine 会有以下几种状态（简化） <ul><li>Waiting, 等待</li><li>Runnable, 就绪，只要 M 给命令就可以运行</li><li>Executing, 运行，在 M 上执行命令</li></ul></li></ul><p>runtime 程序在程序启动时，会创建 M 个线程，之后会有 N 个 goroutine，这就是 M:N 模型。</p><ul><li>工作窃取<br> 当一个 P 发现自己的工作队列 LRQ 没有 G 时，会从其他 P 中“偷”一些 G 来运行，就是 <code>work stealing</code>。</li></ul><blockquote><p>go 的调度还有很多可以深挖，值得不断学习</p></blockquote><h2 id="gc" tabindex="-1"><a class="header-anchor" href="#gc" aria-hidden="true">#</a> GC</h2><ul><li>三色标记法</li></ul><p>go 使用三色标记法来进行 GC，用不同的颜色标记可能需要回收的对象</p><ul><li><p>白色对象（可能死亡）：未被回收器访问到的对象。在回收开始阶段，所有对象均为白色，当回收结束后，白色对象均不可达。</p></li><li><p>灰色对象（波面）：已被回收器访问到的对象，但回收器需要对其中的一个或多个指针进行扫描，因为他们可能还指向白色对象。</p></li><li><p>黑色对象（确定存活）：已被回收器访问到的对象，其中所有字段都已被扫描，黑色对象中任何一个指针都不可能直接指向白色对象。</p></li><li><p>STW</p></li></ul><p>STW 就是 <code>Stop the world</code>，在 GC 时，会进入短暂的暂停所有的运行，拖慢程序。进过不断优化，现在的 GC 仅需要几毫秒。</p><h2 id="编译与运行" tabindex="-1"><a class="header-anchor" href="#编译与运行" aria-hidden="true">#</a> 编译与运行</h2><h4 id="go-程序的运行过程" tabindex="-1"><a class="header-anchor" href="#go-程序的运行过程" aria-hidden="true">#</a> go 程序的运行过程</h4><p>参考文献里的一篇文章【探索 golang 程序启动过程】研究得比较深入，总结下：</p><ol><li>检查运行平台的 CPU，设置好程序运行需要相关标志。<br> TLS 的初始化。</li><li>runtime.args、runtime.osinit、runtime.schedinit 三个方法做好程序运行需要的各种变量与调度器。</li><li>runtime.newproc 创建新的 goroutine 用于绑定用户写的 main 方法。</li><li>runtime.mstart 开始 goroutine 的调度。<br><img src="'+u+'" alt="image" loading="lazy"></li></ol><h4 id="编译时的逃逸分析" tabindex="-1"><a class="header-anchor" href="#编译时的逃逸分析" aria-hidden="true">#</a> 编译时的逃逸分析</h4><p>简单地讲，逃逸分析就是分析程序中的内存是否会被分配到堆上去，而如果编译器判断变量会被分配到堆上，但变量在函数返回后不会被再次引用，这个变量还是会被分配到栈上。</p><p>go 语音的分析原则是：如果一个函数返回对一个变量的引用，那么它就会发生逃逸。</p><p>逃逸的处理方法是</p><ul><li>如果函数外部没有引用，则优先放到栈中</li><li>如果函数外部存在引用，则必定放到堆中</li></ul><h3 id="阅读" tabindex="-1"><a class="header-anchor" href="#阅读" aria-hidden="true">#</a> 阅读</h3>',20),G={href:"https://golang.design/go-questions/",target:"_blank",rel:"noopener noreferrer"},q={href:"https://draveness.me/golang/",target:"_blank",rel:"noopener noreferrer"},w={href:"https://golang.design/under-the-hood/",target:"_blank",rel:"noopener noreferrer"},C=e("h3",{id:"其他",tabindex:"-1"},[e("a",{class:"header-anchor",href:"#其他","aria-hidden":"true"},"#"),l(" 其他")],-1),P={href:"https://learnku.com/articles/69250",target:"_blank",rel:"noopener noreferrer"};function L(M,B){const i=t("ExternalLinkIcon");return r(),s("div",null,[h,e("ul",null,[e("li",null,[e("p",null,[l("1.18 版本的实现可以通过这里查看："),e("a",g,[l("https://github.com/golang/go/blob/dev.boringcrypto.go1.18/src/runtime/slice.go#L166"),n(i)])])]),e("li",null,[e("p",null,[l("master 分支的实现在这里："),e("a",b,[l("https://github.com/golang/go/blob/master/src/runtime/slice.go#L157"),n(i)]),m,l(" 按照饶大给出的分析，除了在按照规律扩容以外，还会进行内存对齐。")])]),v]),_,e("p",null,[l("需要注意的是，有的文章会提到 go 是协作式调度，但现在 go 会同时有 "),k,l("和"),f,l(" 。 "),e("a",x,[l("细节与原因"),n(i)])]),y,e("ul",null,[e("li",null,[e("p",null,[e("a",G,[l("Go 程序员面试笔试宝典"),n(i)])])]),e("li",null,[e("p",null,[e("a",q,[l("Go 语言设计与实现"),n(i)])])]),e("li",null,[e("p",null,[e("a",w,[l("Go 语言原本"),n(i)])])])]),C,e("ul",null,[e("li",null,[e("a",P,[l("GO 面试题集锦快答"),n(i)])])])])}const T=o(p,[["render",L],["__file","golang.html.vue"]]);export{T as default};
