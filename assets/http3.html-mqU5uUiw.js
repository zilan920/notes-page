import{_ as t}from"./plugin-vue_export-helper-x3n3nnut.js";import{o as T,c as d,e}from"./app-_i4KCvhj.js";const r="/assets/d-pmjqbe3t.png",a="/assets/tls-SDkl8cTA.png",h={},l=e('<h3 id="http3-and-rtt" tabindex="-1"><a class="header-anchor" href="#http3-and-rtt" aria-hidden="true">#</a> HTTP3 and RTT</h3><p><code>i made an presentation serveral years ago, here to reorganize it</code></p><table><thead><tr><th></th><th>HTTP</th><th>HTTPS 1.2 首次连接</th><th>HTTPS 1.2 连接复用</th><th>HTTPS 1.3 首次连接</th><th>HTTPS 1.3 连接复用</th><th>HTTP over QUIC首次连接</th><th>HTTP over QUIC 连接复用</th></tr></thead><tbody><tr><td>TCP握手</td><td>1.5RTT</td><td>1.5RTT</td><td>0 RTT</td><td>1.5RTT</td><td>0 RTT</td><td>-</td><td>-</td></tr><tr><td>TLS握手</td><td>-</td><td>2RTT</td><td>1RTT</td><td>1RTT</td><td>0RTT</td><td>-</td><td>-</td></tr><tr><td>QUIC握手</td><td>-</td><td>-</td><td>-</td><td>-</td><td>-</td><td>1RTT</td><td>0RTT</td></tr><tr><td>HTTP请求&amp;响应</td><td>1RTT</td><td>1RTT</td><td>1RTT</td><td>1RTT</td><td>1RTT</td><td>1RTT</td><td>1RTT</td></tr><tr><td>合计</td><td>2.5RTT</td><td>4.5RTT</td><td>2RTT</td><td>3.5RTT</td><td>1RTT</td><td>2RTT</td><td>1RTT</td></tr></tbody></table><h3 id="http-3-rtt的斗争史" tabindex="-1"><a class="header-anchor" href="#http-3-rtt的斗争史" aria-hidden="true">#</a> http/3 RTT的斗争史</h3><h5 id="什么是rtt" tabindex="-1"><a class="header-anchor" href="#什么是rtt" aria-hidden="true">#</a> 什么是RTT</h5><p>RTT是Round Trip Time的缩写，通俗地说，就是通信一来一回的时间。</p><ul><li>一次HTTP循环的时间</li></ul><p>那么一次TCP建立连接时的握手，一共需要 1.5RTT<br><img src="'+r+'" alt="TCP" loading="lazy"></p><p>而对于一个HTTP请求&amp;响应，加上HTTP Request&amp;Response，算作一个1RTT。</p><p>那么基于TCP的的HTTP的消耗时间总和，就是 1.5RTT + 1RTT = 2.5RTT</p><ul><li>安全加密通信<br> 在TLS中过，一个HTTP循环需要多少RTT？</li></ul><p><img src="'+a+'" alt="TLS" loading="lazy"></p><ul><li>TLS1.2 <ul><li>clientHello</li><li>ServerHello</li><li>验证后发送Client Key Exchange, Change Cipher Spec</li><li>服务端Change Cipher Spec</li></ul></li></ul><p>因此对于采用tls1.2的HTTP连接，所需要 1.5RTT + 1RTT + 2RTT = 4.5RTT</p><p>//- TLS1.3</p><ul><li><p>HTTP 1.x<br> 在HTTP1.x中，每个连接相互独立，因而每一个HTTP请求都需要3.5RTT。最终结果视请求量正比增长。</p></li><li><p>HTTP 2<br> 复用TLS连接，第一个之后的每一个HTTP可以减少1.5RTT + 2RTT = 3.5 RTT时间<br> 问题： 头部阻塞</p></li></ul><p>多路复用允许同时通过单一的 HTTP/2 连接发起多重的请求-响应消息。即连接共享，即每一个 request 都是是用作连接共享机制的。一个 request 对应一个 id，这样一个连接上可以有多个 request，每个连接的 request 可以随机的混杂在一起，接收方可以根据 request 的 id 将 request 再归属到各自不同的服务端请求里面</p><p>HTTP1.x 的 header 带有大量信息，而且每次都要重复发送，HTTP/2 使用 encoder 来减少需要传输的 header 大小，通讯双方各自cache 一份 header fields 表，既避免了重复 header 的传输，又减小了需要传输的大小。<br> 为了减少这块的资源消耗并提升性能， HTTP/2 对这些首部采取了压缩策略：</p><p>链接耗时更短<br> 拥塞控制更出色<br> 更好的多路复用<br> 前向纠错特性<br> 链接迁移特性</p>',19),i=[l];function p(s,R){return T(),d("div",null,i)}const c=t(h,[["render",p],["__file","http3.html.vue"]]);export{c as default};
