<?xml version="1.0" encoding="utf-8"?><?xml-stylesheet type="text/xsl" href="https://notes-page-mu.vercel.app/rss.xsl"?>
<rss version="2.0" xmlns:atom="http://www.w3.org/2005/Atom" xmlns:content="http://purl.org/rss/1.0/modules/content/" xmlns:dc="http://purl.org/dc/elements/1.1/">
  <channel>
    <atom:link href="https://notes-page-mu.vercel.app/rss.xml" rel="self" type="application/rss+xml"/>
    <title>我的笔记</title>
    <link>https://notes-page-mu.vercel.app/</link>
    <description>我的笔记</description>
    <language>zh-CN</language>
    <pubDate>Sun, 04 Feb 2024 06:38:46 GMT</pubDate>
    <lastBuildDate>Sun, 04 Feb 2024 06:38:46 GMT</lastBuildDate>
    <generator>vuepress-plugin-feed2</generator>
    <docs>https://validator.w3.org/feed/docs/rss2.html</docs>
    <item>
      <title>算法题</title>
      <link>https://notes-page-mu.vercel.app/contents/%E7%AE%97%E6%B3%95%E9%A2%98.html</link>
      <guid>https://notes-page-mu.vercel.app/contents/%E7%AE%97%E6%B3%95%E9%A2%98.html</guid>
      <source url="https://notes-page-mu.vercel.app/rss.xml">算法题</source>
      <description>数据结构 数组 移除元素 func removeElement(nums []int, val int) int { slow, fast := 0, 0 for fast &amp;lt; len(nums) { if nums[fast] != val { nums[slow] = nums[fast] slow ++ } fast ++ } return slow }</description>
      <pubDate>Sun, 04 Feb 2024 02:50:16 GMT</pubDate>
      <content:encoded><![CDATA[<h2> 数据结构</h2>
<h3> 数组</h3>
<ul>
<li><a href="https://leetcode.cn/problems/remove-element/description/" target="_blank" rel="noopener noreferrer">移除元素</a></li>
</ul>
<div class="language-go line-numbers-mode" data-ext="go"><div class="line-numbers" aria-hidden="true"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div><ul>
<li><a href="https://leetcode.cn/problems/move-zeroes/description" target="_blank" rel="noopener noreferrer">移动零</a></li>
</ul>
<div class="language-go line-numbers-mode" data-ext="go"><div class="line-numbers" aria-hidden="true"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div><ul>
<li><a href="https://leetcode.cn/problems/merge-intervals/description" target="_blank" rel="noopener noreferrer">合并区间</a></li>
</ul>
<h3> 链表</h3>
<ul>
<li><a href="https://leetcode.cn/problems/reverse-linked-list/description" target="_blank" rel="noopener noreferrer">反转链表</a></li>
</ul>
<div class="language-go line-numbers-mode" data-ext="go"><div class="line-numbers" aria-hidden="true"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div><ul>
<li><a href="https://leetcode.cn/problems/merge-two-sorted-lists/description" target="_blank" rel="noopener noreferrer">合并两个有序链表</a></li>
</ul>
<div class="language-go line-numbers-mode" data-ext="go"><div class="line-numbers" aria-hidden="true"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div><ul>
<li>
<p><a href="https://leetcode.cn/problems/merge-k-sorted-lists/description" target="_blank" rel="noopener noreferrer">合并K个升序链表</a></p>
</li>
<li>
<p><a href="https://leetcode.cn/problems/add-two-numbers/description" target="_blank" rel="noopener noreferrer">两数相加</a></p>
</li>
</ul>
<h3> 哈希表</h3>
<h3> 二叉树</h3>
<ul>
<li>
<p><a href="https://leetcode.cn/problems/invert-binary-tree/description" target="_blank" rel="noopener noreferrer">翻转二叉树</a></p>
</li>
<li>
<p><a href="https://leetcode.cn/problems/binary-tree-inorder-traversal/description" target="_blank" rel="noopener noreferrer">二叉树的中序遍历</a></p>
</li>
<li>
<p><a href="https://leetcode.cn/problems/binary-tree-level-order-traversal/description" target="_blank" rel="noopener noreferrer">二叉树的层序遍历</a></p>
</li>
<li>
<p><a href="https://leetcode.cn/problems/validate-binary-search-tree/description" target="_blank" rel="noopener noreferrer">验证二叉搜索树</a></p>
</li>
<li>
<p><a href="https://leetcode.cn/problems/flatten-binary-tree-to-linked-list/description" target="_blank" rel="noopener noreferrer">二叉树展开为链表</a></p>
</li>
</ul>
<h3> 字符串</h3>
<h3> 栈，堆与队列</h3>
<ul>
<li>
<p><a href="https://leetcode.cn/problems/valid-parentheses/description" target="_blank" rel="noopener noreferrer">有效的括号</a></p>
</li>
<li>
<p><a href="https://leetcode.cn/problems/min-stack/description" target="_blank" rel="noopener noreferrer">最小栈</a></p>
</li>
</ul>
<div class="language-go line-numbers-mode" data-ext="go"><div class="line-numbers" aria-hidden="true"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div><ul>
<li><a href="https://leetcode.cn/problems/kth-largest-element-in-an-array/description" target="_blank" rel="noopener noreferrer">数组中第k大个元素</a></li>
</ul>
<h3> 数据结构设计</h3>
<ul>
<li>LRU</li>
</ul>
<h2> 算法</h2>
<h3> 贪心法</h3>
<h3> 回溯法</h3>
<ul>
<li><a href="https://leetcode.cn/problems/permutations/description" target="_blank" rel="noopener noreferrer">全排列</a></li>
</ul>
<div class="language-go line-numbers-mode" data-ext="go"><div class="line-numbers" aria-hidden="true"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div><h3> DFS</h3>
<h3> BFS</h3>
<h3> 动态规划法</h3>
<ul>
<li>
<p><a href="https://leetcode.cn/problems/maximum-subarray/description" target="_blank" rel="noopener noreferrer">最大子数组和</a></p>
</li>
<li>
<p><a href="https://leetcode.cn/problems/climbing-stairs/description" target="_blank" rel="noopener noreferrer">爬楼梯</a></p>
</li>
<li>
<p><a href="https://leetcode.cn/problems/coin-change/description" target="_blank" rel="noopener noreferrer">换零钱</a></p>
</li>
<li>
<p><a href="https://leetcode.cn/problems/longest-increasing-subsequence/description" target="_blank" rel="noopener noreferrer">最长递增子序列</a></p>
</li>
</ul>
<div class="language-go line-numbers-mode" data-ext="go"><div class="line-numbers" aria-hidden="true"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div><h3> 二分搜索</h3>
<h3> 排序</h3>
<h2> 算法技巧</h2>
<h3> 双指针</h3>
<ul>
<li><a href="https://leetcode.cn/problems/container-with-most-water/description" target="_blank" rel="noopener noreferrer">盛最多水的容器</a></li>
</ul>
<h3> 滑动窗口</h3>
<ul>
<li><a href="https://leetcode.cn/problems/longest-substring-without-repeating-characters/description" target="_blank" rel="noopener noreferrer">无重复字符的最长子串</a></li>
</ul>
<div class="language-go line-numbers-mode" data-ext="go"><div class="line-numbers" aria-hidden="true"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div><h3> 前缀和与差分数组</h3>
<ul>
<li><a href="https://leetcode.cn/problems/subarray-sum-equals-k/description" target="_blank" rel="noopener noreferrer">和为 K 的子数组</a></li>
</ul>
]]></content:encoded>
    </item>
    <item>
      <title>HTTP3 and RTT</title>
      <link>https://notes-page-mu.vercel.app/contents/http3.html</link>
      <guid>https://notes-page-mu.vercel.app/contents/http3.html</guid>
      <source url="https://notes-page-mu.vercel.app/rss.xml">HTTP3 and RTT</source>
      <description>几年前做了关于HTTP3的分享，为了避免遗忘，将内容整理出来并完善 什么是RTT RTT是Round Trip Time的缩写，通俗地说，就是通信一来一回的时间。我们可以使用RTT快速评估协议所需要的传输时间。 一次HTTP循环的时间 那么一次TCP建立连接时的握手，一共需要 1.5RTT 而对于一个HTTP请求&amp;amp;响应，加上HTTP Request&amp;amp;Response，算作一个1RTT。 那么基于TCP的的HTTP的消耗时间总和，就是 1.5RTT + 1RTT = 2.5RTT</description>
      <pubDate>Wed, 31 Jan 2024 07:59:26 GMT</pubDate>
      <content:encoded><![CDATA[<p><code>几年前做了关于HTTP3的分享，为了避免遗忘，将内容整理出来并完善</code></p>
<h5> 什么是RTT</h5>
<p>RTT是Round Trip Time的缩写，通俗地说，就是通信一来一回的时间。我们可以使用RTT快速评估协议所需要的传输时间。</p>
<h5> 一次HTTP循环的时间</h5>
<p>那么一次TCP建立连接时的握手，一共需要 1.5RTT<br>
</p>
<p>而对于一个HTTP请求&amp;响应，加上HTTP Request&amp;Response，算作一个1RTT。</p>
<p>那么基于TCP的的HTTP的消耗时间总和，就是 1.5RTT + 1RTT = 2.5RTT</p>
<h5> 关于TLS下的RTT影响</h5>
<p>在TLS下，一个HTTP循环需要多少RTT？</p>
<p>让我们先看一下啊TLS1.2的过程</p>
<ul>
<li>clientHello</li>
<li>ServerHello, Ask for certificate</li>
<li>验证后发送Client Key Exchange, Change Cipher Spec</li>
<li>服务端Change Cipher Spec</li>
</ul>
<p>因此TLS1.2 握手时，总共需要2RTT的时间</p>
<p>对于非首次连接，可以选择启用会话重用(Session Resumption)，可以缩小时间到1RTT</p>
<p>因而对于采用tls1.2的HTTP连接，需要 1.5 RTT (TCP)+ 1 RTT (HTTP Request &amp; Response) + 2RTT(TLS) = 4.5RTT 时间</p>
<ul>
<li>TLS1.3</li>
</ul>
<p>TLS1.3 引入了TLS1.2 会话重用机制的升级：密钥协商机制 - PSK (pre shared key)，使得消耗时间变为1 RTT</p>
<p>同样，对于非首次握手，可以支持 增加Early Data ，直接在握手阶段发送数据，相当于0-RTT （发送数据不需要额外RTT，即为0RTT）</p>
<p>因而一个HTTP通讯，需要 1.5 RTT(TCP)+ 1 RTT(HTTP Request &amp; Response) + 1RTT(TLS) = 3.5RTT 时间</p>
<p></p>
<h5> 关于HTTP的影响</h5>
<ul>
<li>HTTP1.x支持长连接 keep-live， pipeline</li>
</ul>
<p>在HTTP1.x中，每个连接相互独立，因而每一个HTTP请求都需要3.5RTT。最终结果视请求量正比增长。开启keep-live 后，可以为后续的连接复用已开启的TCP，从而减少后续所需时间。</p>
<p>长连接带来的问题：但是在同一个 TCP 连接里面，所有的数据通信是按次序进行的。服务器只有处理完一个回应，才会进行下一个回应。要是前面的回应特别慢，后面就会有许多请求排队等着。这称为"队头堵塞"（Head-of-line blocking）。</p>
<p>这也带来pipeline技术，在相应到达之前，可以将多条请求放入队列，当第一条请求发往服务器的时候，第二第三条请求也可以开始发送了。<br>
</p>
<ul>
<li>HTTP/2 多路复用，头信息压缩</li>
</ul>
<p>HTTP2 带来了多路复用，允许同时通过单一的 HTTP/2 连接发起多重的请求-响应消息。即连接共享，即每一个 request 都是是用作连接共享机制的。一个 request 对应一个 id，这样一个连接上可以有多个 request，每个连接的 request 可以随机的混杂在一起，接收方可以根据 request 的 id 将 request 再归属到各自不同的服务端请求里面</p>
<p>复用TLS连接，第一个之后的每一个HTTP可以减少1.5RTT + 2RTT = 3.5 RTT时间<br>
</p>
<p>在HTTP1.x中， header常常带有大量信息，而且每次都要重复发送，HTTP/2 使用 encoder 来减少需要传输的 header 大小，通讯双方各自cache 一份 header fields 表，既避免了重复 header 的传输，又减小了需要传输的大小。<br>
</p>
<h5> QUIC !!</h5>
<p>Quic 全称 quick udp internet connection，和英文 quick 谐音，简称“快”）是由 google 提出的使用 udp 进行多路并发传输的协议。</p>
<ul>
<li>
<p>强大优势</p>
<ul>
<li>链接耗时更短，非首次连接支持0RTT</li>
<li>拥塞控制更出色</li>
<li>更好的多路复用</li>
<li>前向纠错特性</li>
<li>链接迁移特性<br>
</li>
</ul>
</li>
<li>
<p>华丽转身</p>
</li>
</ul>
<p>2018年 HTTP Over QUIC 更名 HTTP/3<br>
</p>
<h5> 对比</h5>
<table>
<thead>
<tr>
<th></th>
<th>HTTP</th>
<th>HTTPS 1.2 首次连接</th>
<th>HTTPS 1.2 连接复用</th>
<th>HTTPS 1.3 首次连接</th>
<th>HTTPS 1.3 连接复用</th>
<th>HTTP over QUIC首次连接</th>
<th>HTTP over QUIC  连接复用</th>
</tr>
</thead>
<tbody>
<tr>
<td>TCP握手</td>
<td>1.5RTT</td>
<td>1.5RTT</td>
<td>0 RTT</td>
<td>1.5RTT</td>
<td>0 RTT</td>
<td>-</td>
<td>-</td>
</tr>
<tr>
<td>TLS握手</td>
<td>-</td>
<td>2RTT</td>
<td>1RTT</td>
<td>1RTT</td>
<td>0RTT</td>
<td>-</td>
<td>-</td>
</tr>
<tr>
<td>QUIC握手</td>
<td>-</td>
<td>-</td>
<td>-</td>
<td>-</td>
<td>-</td>
<td>1RTT</td>
<td>0RTT</td>
</tr>
<tr>
<td>HTTP请求&amp;响应</td>
<td>1RTT</td>
<td>1RTT</td>
<td>1RTT</td>
<td>1RTT</td>
<td>1RTT</td>
<td>1RTT</td>
<td>1RTT</td>
</tr>
<tr>
<td>合计</td>
<td>2.5RTT</td>
<td>4.5RTT</td>
<td>2RTT</td>
<td>3.5RTT</td>
<td>1RTT</td>
<td>2RTT</td>
<td>1RTT</td>
</tr>
</tbody>
</table>
]]></content:encoded>
    </item>
    <item>
      <title>Leetcode</title>
      <link>https://notes-page-mu.vercel.app/contents/Leetcode.html</link>
      <guid>https://notes-page-mu.vercel.app/contents/Leetcode.html</guid>
      <source url="https://notes-page-mu.vercel.app/rss.xml">Leetcode</source>
      <description>思路 双指针与链表 合并有序链表 拉链法 多个链表合并：优先队列 拆分链表 直接使用两个节点遍历，按条件分别生成两个链表，最后合并起来，注意中途要拆分原有的关联 合并k个有序链表 类似合并2个有序链表，但这里使用到了优先级队列，快速找到最小的节点。优先级队列属于单独的数据结构，需要了解 单链表的倒数第 k 个节点 两个指针，第一个先走k步，再将两个指针一起走，最后第一个指针到达尾部时，第二个刚好走了n-k步 类似的还有删除倒数第k个节点 链表中点 直接使用快慢指针 判断是否包含环 使用快慢指针，如果两个指针相交则表示包含环，相交后任意一个节点回到头，然后相同速度往前走，再次相交则为相交的起点。 两个链表是否相交 两个指针分别依次走两个链表，最后看是否相交。 类似的，也可以将两个链表首位相连，判断是否存在环 递归反转</description>
      <pubDate>Wed, 13 Dec 2023 08:06:56 GMT</pubDate>
      <content:encoded><![CDATA[<h2> 思路</h2>
<ul>
<li>双指针与链表
<ul>
<li>
<p>合并有序链表</p>
<ul>
<li>拉链法</li>
<li>多个链表合并：优先队列</li>
</ul>
</li>
<li>
<p>拆分链表</p>

</li>
<li>
<p>合并k个有序链表</p>

</li>
<li>
<p>单链表的倒数第 k 个节点</p>

</li>
<li>
<p>链表中点</p>

</li>
<li>
<p>判断是否包含环</p>

</li>
<li>
<p>两个链表是否相交</p>

</li>
<li>
<p>递归反转</p>
</li>
</ul>
</li>
</ul>
<div class="language-golang line-numbers-mode" data-ext="golang"><div class="line-numbers" aria-hidden="true"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div><ul>
<li>
<p>双指针与数组</p>
</li>
<li>
<p>有序数组二分搜索</p>
</li>
<li>
<p>二分搜索重在细节，特别是左右边界的判断，以及判断之后mid的变化</p>
</li>
<li>
<p>二分不仅仅用于显然的搜索场景，也可以用于一些特殊的搜索场景（如求极值）</p>

</li>
<li>
<p>田忌赛马</p>

</li>
<li>
<p>快慢指针</p>
<ul>
<li>
<p>原地修改数组</p>

</li>
</ul>
</li>
<li>
<p>左右指针</p>
<ul>
<li>
<p>二分查找</p>

</li>
<li>
<p>两数之和，但是是有序数组</p>

</li>
<li>
<p>翻转数组</p>

</li>
<li>
<p>判断回文</p>

</li>
</ul>
</li>
<li>
<p>动态规划法</p>
<p>核心思想在于找到分解问题，将问题降级再重新组装<br>
斐波那契数列：分解为前面2个数之和<br>
最长递增自学：当前序列是否为递增，新增下一个值是否依然为递增</p>
</li>
<li>
<p>回溯法</p>
<p>代码框架</p>
</li>
</ul>
<div class="language-text line-numbers-mode" data-ext="text"><div class="line-numbers" aria-hidden="true"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div>
<ul>
<li>BFS</li>
</ul>
<div class="language-java line-numbers-mode" data-ext="java"><div class="line-numbers" aria-hidden="true"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div>
<ul>
<li>
<p>二分搜索</p>
<p>最重要还是细节</p>
</li>
<li>
<p>滑动窗口算法</p>
</li>
</ul>
<div class="language-c++ line-numbers-mode" data-ext="c++"><div class="line-numbers" aria-hidden="true"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div><ul>
<li>
<p>n数之和</p>
<p>依然是将数组排序，左右指针互博。如果要获取大于2的结果，例如3数之和，则将一个数取出，计算剩下数组的n-k结果。</p>
</li>
</ul>
<h2> 核心思路</h2>
<h3> 基础数据结构</h3>
<h4> 数组/链表</h4>
<ul>
<li>
<p>数组思路：前缀和</p>
<p>将数组转换为前缀和，可以方便的计算某一段的和，也可以用于二维数组，计算范围的和</p>
</li>
<li>
<p>数组思路：差分数组</p>
<p>差分数组是前缀和的逆运算，可以用于区间加法，航班预订等问题。<br>
差分数组的特点是，可以方便的一个数组批量的进行操作，当我们为一个数组区间进行增加或减小时，可以为仅操作差分数组区间的第一个与最后一个。再恢复为原有的数组。</p>
</li>
<li>
<p>滑动窗口法</p>
<p>滑动窗口是一种非常常用的算法思路，可以用来解决子串等问题。<br>
与滑动窗口类似的还有快慢指针，左右指针，都是通过两个指针对链表进行操作。<br>
一个简单的滑动窗口算法可以是这样</p>
</li>
</ul>
<div class="language-c++ line-numbers-mode" data-ext="c++"><div class="line-numbers" aria-hidden="true"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div><ul>
<li>有序数组二分搜索</li>
<li>原地修改数组</li>
<li>单链表</li>
<li>链表合并，链表分割</li>
<li>链表倒数第k个节点</li>
<li>链表中点，是否有环</li>
<li>两个链表是否相交</li>
<li>递归操作链表</li>
</ul>
<h4> 队列/栈</h4>
<ul>
<li>队列和栈相互实现</li>
<li>括号匹配问题</li>
</ul>
<h4> 数据结构设计</h4>
<ul>
<li>LRU算法</li>
<li>LFU算法</li>
<li>查找/删除数组中任意元素</li>
</ul>
<h3> 进阶数据结构</h3>
<h4> 二叉树</h4>
<h4> 二叉搜索树</h4>
<h4> 图</h4>
<h3> 暴力算法</h3>
<ul>
<li>DFS/回溯算法</li>
<li>BFS算法</li>
</ul>
<h3> 动态规划</h3>
<h4> 经典动态规划</h4>
<h4> 背包问题</h4>
]]></content:encoded>
    </item>
    <item>
      <title>go语言学习</title>
      <link>https://notes-page-mu.vercel.app/contents/golang.html</link>
      <guid>https://notes-page-mu.vercel.app/contents/golang.html</guid>
      <source url="https://notes-page-mu.vercel.app/rss.xml">go语言学习</source>
      <description>go 数据结构 切片和数组 slice 的底层是数组，是对数组的封装，可以用于描述数组的一个片段，两者都可以用于描述。 数组是定长的，而切片则可以动态的扩容。 在存储上，数组是一片连续的内存，而 slice 实质上是一个结构体。他的结构如下： // runtime/slice.go type slice struct { 	array unsafe.Pointer // 元素指针 	len int // 长度 	cap int // 容量 }</description>
      <pubDate>Wed, 13 Dec 2023 07:24:37 GMT</pubDate>
      <content:encoded><![CDATA[<h2> go 数据结构</h2>
<h4> 切片和数组</h4>
<p>slice 的底层是数组，是对数组的封装，可以用于描述数组的一个片段，两者都可以用于描述。<br>
数组是定长的，而切片则可以动态的扩容。<br>
在存储上，数组是一片连续的内存，而 slice 实质上是一个结构体。他的结构如下：</p>
<div class="language-golang line-numbers-mode" data-ext="golang"><div class="line-numbers" aria-hidden="true"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div><ul>
<li>切片的扩容<br>
当我们向 slice 中追加了元素后，如果空间不足时就会引起扩容。<br>
按照以往常见的说法，在 golang1.18 版本更新之前网上大多数的文章都是这样描述 slice 的扩容策略的：</li>
</ul>
<blockquote>
<p>当原 slice 容量小于 1024 的时候，新 slice 容量变成原来的 2 倍；原 slice 容量超过 1024，新 slice 容量变成原来的 1.25 倍。</p>
</blockquote>
<p>在 1.18 版本更新之后，slice 的扩容策略变为了：</p>
<blockquote>
<p>当原 slice 容量(oldcap)小于 256 的时候，新 slice(newcap)容量为原来的 2 倍；原 slice 容量超过 256，新 slice 容量 newcap = oldcap+(oldcap+3*256)/4</p>
</blockquote>
<p>可以看到这是会按照版本动态变化的，扩容的实际实现位于 src/runtime/slice.go 中的 growslice 。</p>
<ul>
<li>
<p>1.18 版本的实现可以通过这里查看：<a href="https://github.com/golang/go/blob/dev.boringcrypto.go1.18/src/runtime/slice.go#L166" target="_blank" rel="noopener noreferrer">https://github.com/golang/go/blob/dev.boringcrypto.go1.18/src/runtime/slice.go#L166</a></p>
</li>
<li>
<p>master 分支的实现在这里：<a href="https://github.com/golang/go/blob/master/src/runtime/slice.go#L157" target="_blank" rel="noopener noreferrer">https://github.com/golang/go/blob/master/src/runtime/slice.go#L157</a><br>
按照饶大给出的分析，除了在按照规律扩容以外，还会进行内存对齐。</p>
</li>
<li>
<p>切片作为函数参考</p>
</li>
</ul>
<blockquote>
<p>go 中的所有函数传值，都是值传递，没有引用传递。即便是传递了参数指针时，也只是基于内存地址对原有的变量进行操作。</p>
</blockquote>
<p>slice 作为函数参数传递时，都会是按照值传递复制这个数据。但由于 slice 本身会携带一个底层数组的指针，在直接操作 slice 中的变量，例如<code>slice[i] = 1</code>时，则会直接改变到原有的数组的值。</p>
<p>而如果我们对复制的值进行其他操作，如<code>append</code>时，则会生成一个新的 slice，此时原有的数组则不会受到影响。</p>
<blockquote>
<p>推测：当我们对一个 slice 操作时，如果没有涉及到原有 slice 的扩容，是否也会影响到？</p>
</blockquote>
<h4> map</h4>
<ul>
<li>map 的实现<br>
go 中 map 的底层是一个 hmap</li>
</ul>
<div class="language-golang line-numbers-mode" data-ext="golang"><div class="line-numbers" aria-hidden="true"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div><p><img src="/images/map.png" alt="image" loading="lazy"></p>
<p>map 的哈希函数：在程序启动时，会检测 cpu 是否支持 aes，如果支持，则使用 aes hash，否则使用 memhash。<br>
map 使用链地址法处理哈希冲突，因此当哈希碰撞发生时，map 会最终退化成一个链表。</p>
<ul>
<li>
<p>map 的遍历<br>
map 会在遍历开始时，生成随机树种子，随机的访问其中的一个 bucket，另外由于 map 会有扩容搬迁过程，导致 map 的遍历是<strong>一定</strong>会无序的</p>
</li>
<li>
<p>map 的查找</p>
</li>
</ul>
<ol>
<li>写保护机制<br>
先查 hmap 的标志位 flags,如果 flags 写标志位此时是 1,说明其他协程正在写操作,直接 panic</li>
<li>计算 hash 值<br>
key 经过哈希函数计算后,得到 64bit(64 位 CPU)<br>
10010111 | 101011101010110101010101101010101010 | 10010</li>
<li>找到 hash 对应的桶<br>
上面 64 位后 5(hmap 的 B 值)位定位所存放的桶<br>
如果当前正在扩容中,并且定位到旧桶数据还未完成迁移,则使用旧的桶</li>
<li>遍历桶查找<br>
上面 64 位前 8 位用来在 tophash 数组查找快速判断 key 是否在当前的桶中,如果不在需要去溢出桶查找</li>
<li>返回 key 对应的指针</li>
</ol>
<ul>
<li>
<p>map 的赋值</p>
</li>
<li>
<p>map 的扩容</p>
<ul>
<li>
<p>扩容时机：向 map 插入新 key 的时候，会进行条件检测，符合下面这 2 个条件，就会触发扩容</p>
<ul>
<li>
<p>超过负载 map 元素个数 &gt; 6.5（负载因子） * 桶个数</p>
<blockquote>

</blockquote>

</li>
<li>
<p>溢出桶太多<br>
当桶总数&lt;2^15 时，如果溢出桶总数&gt;=桶总数，则认为溢出桶过多<br>
当桶总数&gt;2^15 时，如果溢出桶总数&gt;=2^15，则认为溢出桶过多</p>
</li>
</ul>
</li>
<li>
<p>扩容机制：</p>
<ul>
<li>双倍扩容：针对条件 1，新建一个 buckets 数组，新的 buckets 大小是原来的 2 倍，然后旧 buckets 数据搬迁到新的 buckets。</li>
<li>等量扩容：针对条件 2，并不扩大容量，buckets 数量维持不变，重新做一遍类似双倍扩容的搬迁动作，把松散的键值对重新排列一次，使得同一个 bucket 中的 key 排列地更紧密，节省空间，提高 bucket 利用率，进而保证更快的存取。</li>
</ul>
</li>
<li>
<p>渐进式扩容：<br>
插入修改删除 key 的时候，都会尝试进行搬迁桶的工作，每次都会检查 oldbucket 是否 nil，如果不是 nil 则每次搬迁 2 个桶，蚂蚁搬家一样渐进式扩容</p>
</li>
</ul>
</li>
<li>
<p>map 的 key 可以有哪些</p>
</li>
</ul>
<p>Go 语言中只要是可比较的类型都可以作为 key。除开 slice，map，functions 这几种类型，其他类型都是 OK 的。具体包括：布尔值、数字、字符串、指针、通道、接口类型、结构体、只包含上述类型的数组。<br>
任何类型都可以作为 value，包括 map 类型。</p>
<ul>
<li>
<p>map 的线程安全<br>
map 不是一个线程安全的结构，同时读写时会直接 panic。<br>
但如果在同一个协程内进行同时读写，不会被编译器检测到，但这是危险的操作。一般可以通过<code>sync.RWMutex</code>解决<br>
<code>sync.Map</code>是线程安全的 map，可以用来使用，但<code>sync.Map</code>没有<code>len</code>方法，需要自己遍历实现。</p>
</li>
<li>
<p>map 深度相等的条件：</p>
</li>
</ul>
<ol>
<li>都为 nil</li>
<li>非空、长度相等，指向同一个 map 实体对象</li>
<li>相应的 key 指向的 value “深度”相等</li>
</ol>
<h2> 接口 Interface</h2>
<ul>
<li>接口</li>
</ul>
<p>接口支持鸭子类型<code>Duck Typing</code>。也就是编译器可以通过判断一个类型是否显式的实现了某一个接口。如果有，那么即便没有声明，也会被认为实现了该接口。</p>
<ul>
<li>接口的值接受者和指针接受者</li>
</ul>
<p>直接说结果：值接受者和指针接受者可以直接混用，这是编译器做了一些隐式转换。</p>
<table>
<thead>
<tr>
<th>-</th>
<th>值接收者</th>
<th>指针接收者</th>
</tr>
</thead>
<tbody>
<tr>
<td>值类型调用者</td>
<td>方法会使用调用者的一个副本，类似于“传值”</td>
<td>使用值的引用来调用方法</td>
</tr>
<tr>
<td>指针类型调用者</td>
<td>指针被解引用为值</td>
<td>实际上也是“传值”，方法里的操作会影响到调用者，类似于指针传参，拷贝了一份指针</td>
</tr>
</tbody>
</table>
<p>使用指针作为方法的接收者的理由：</p>
<ul>
<li>方法能够修改接收者指向的值。</li>
<li>避免在每次调用方法时复制该值，在值的类型为大型结构体时，这样做会更加高效。</li>
</ul>
<h2> Channel</h2>
<h2> go 标准库</h2>
<h2> 调度器</h2>
<ul>
<li>调度器<br>
go 程序的执行由两部分组成，go Program 和 Runtime， 他们通过函数调用来实现内存灌流吗，channel 通信，goroutines 创建等。用户程序进行的系统调用都会被拦截，以此来帮助它进行调度和 GC。</li>
</ul>
<p>调度器有 3 个最基础的部分，g, m, p。</p>
<ul>
<li>
<p><code>g</code>表示一个 goroutine，他表示 goroutine 栈的一些字段，指示当前运行的状态</p>
</li>
<li>
<p><code>m</code>表示内核线程，包含正在运行的 goroutine 等字段</p>
</li>
<li>
<p><code>p</code>表示一个虚拟的 Processor，它维护一个处于 runnalbe 的 g 队列，m 需要获得 p 才能运行。</p>
</li>
</ul>
<p>当然还有一个核心结构体<code>sched</code>，它纵览全局。</p>
<p>需要注意的是，有的文章会提到 go 是协作式调度，但现在 go 会同时有 <code>同步协作式调度</code>和<code>异步抢占式调度</code> 。 <a href="https://golang.design/under-the-hood/zh-cn/part2runtime/ch06sched/preemption/" target="_blank" rel="noopener noreferrer">细节与原因</a></p>
<p>调度器的运行比较复杂，我们从我们需要知道的部分入手即可。<br>
<img src="/images/gmp-flow.png" alt="image" loading="lazy"></p>
<ul>
<li>goroutine<br>
一个 goroutine 会有以下几种状态（简化）
<ul>
<li>Waiting, 等待</li>
<li>Runnable, 就绪，只要 M 给命令就可以运行</li>
<li>Executing, 运行，在 M 上执行命令</li>
</ul>
</li>
</ul>
<p>runtime 程序在程序启动时，会创建 M 个线程，之后会有 N 个 goroutine，这就是 M:N 模型。</p>
<ul>
<li>工作窃取<br>
当一个 P 发现自己的工作队列 LRQ 没有 G 时，会从其他 P 中“偷”一些 G 来运行，就是 <code>work stealing</code>。</li>
</ul>
<blockquote>
<p>go 的调度还有很多可以深挖，值得不断学习</p>
</blockquote>
<h2> GC</h2>
<ul>
<li>三色标记法</li>
</ul>
<p>go 使用三色标记法来进行 GC，用不同的颜色标记可能需要回收的对象</p>
<ul>
<li>
<p>白色对象（可能死亡）：未被回收器访问到的对象。在回收开始阶段，所有对象均为白色，当回收结束后，白色对象均不可达。</p>
</li>
<li>
<p>灰色对象（波面）：已被回收器访问到的对象，但回收器需要对其中的一个或多个指针进行扫描，因为他们可能还指向白色对象。</p>
</li>
<li>
<p>黑色对象（确定存活）：已被回收器访问到的对象，其中所有字段都已被扫描，黑色对象中任何一个指针都不可能直接指向白色对象。</p>
</li>
<li>
<p>STW</p>
</li>
</ul>
<p>STW 就是 <code>Stop the world</code>，在 GC 时，会进入短暂的暂停所有的运行，拖慢程序。进过不断优化，现在的 GC 仅需要几毫秒。</p>
<h2> 编译与运行</h2>
<h4> go 程序的运行过程</h4>
<p>参考文献里的一篇文章【探索 golang 程序启动过程】研究得比较深入，总结下：</p>
<ol>
<li>检查运行平台的 CPU，设置好程序运行需要相关标志。<br>
TLS 的初始化。</li>
<li>runtime.args、runtime.osinit、runtime.schedinit 三个方法做好程序运行需要的各种变量与调度器。</li>
<li>runtime.newproc 创建新的 goroutine 用于绑定用户写的 main 方法。</li>
<li>runtime.mstart 开始 goroutine 的调度。<br>
<img src="/images/go_start.png" alt="image" loading="lazy"></li>
</ol>
<h4> 编译时的逃逸分析</h4>
<p>简单地讲，逃逸分析就是分析程序中的内存是否会被分配到堆上去，而如果编译器判断变量会被分配到堆上，但变量在函数返回后不会被再次引用，这个变量还是会被分配到栈上。</p>
<p>go 语音的分析原则是：如果一个函数返回对一个变量的引用，那么它就会发生逃逸。</p>
<p>逃逸的处理方法是</p>
<ul>
<li>如果函数外部没有引用，则优先放到栈中</li>
<li>如果函数外部存在引用，则必定放到堆中</li>
</ul>
<h3> 阅读</h3>
<ul>
<li>
<p><a href="https://golang.design/go-questions/" target="_blank" rel="noopener noreferrer">Go 程序员面试笔试宝典</a></p>
</li>
<li>
<p><a href="https://draveness.me/golang/" target="_blank" rel="noopener noreferrer">Go 语言设计与实现</a></p>
</li>
<li>
<p><a href="https://golang.design/under-the-hood/" target="_blank" rel="noopener noreferrer">Go 语言原本</a></p>
</li>
</ul>
<h3> 其他</h3>
<ul>
<li><a href="https://learnku.com/articles/69250" target="_blank" rel="noopener noreferrer">GO 面试题集锦快答</a></li>
</ul>
]]></content:encoded>
      <enclosure url="https://notes-page-mu.vercel.app/images/map.png" type="image/png"/>
    </item>
    <item>
      <title>阅读</title>
      <link>https://notes-page-mu.vercel.app/contents/Books.html</link>
      <guid>https://notes-page-mu.vercel.app/contents/Books.html</guid>
      <source url="https://notes-page-mu.vercel.app/rss.xml">阅读</source>
      <description>pdf链接 labuladong的刷题笔记V1.0 labuladong的算法秘籍V1.0 其他 币圈红宝书</description>
      <pubDate>Fri, 09 Dec 2022 07:23:51 GMT</pubDate>
      <content:encoded><![CDATA[<h3> pdf链接</h3>
<ul>
<li>
<p><a href="/files/pdf/labuladong%E7%9A%84%E5%88%B7%E9%A2%98%E7%AC%94%E8%AE%B0V1.0.pdf">labuladong的刷题笔记V1.0</a></p>
</li>
<li>
<p><a href="/files/pdf/labuladong%E7%9A%84%E7%AE%97%E6%B3%95%E7%A7%98%E7%B1%8DV1.0.pdf">labuladong的算法秘籍V1.0</a></p>
</li>
</ul>
<h3> 其他</h3>
<ul>
<li><a href="/files/pdf/%E5%B8%81%E5%9C%88%E7%BA%A2%E5%AE%9D%E4%B9%A6.pdf">币圈红宝书</a></li>
</ul>
]]></content:encoded>
    </item>
  </channel>
</rss>