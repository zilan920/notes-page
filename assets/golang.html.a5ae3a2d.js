import{_ as s}from"./_plugin-vue_export-helper.cdc0426e.js";import{o as t,c as r,a as e,b as a,d as n,e as l,r as d}from"./app.fc819b31.js";const c={},o=l(`<h2 id="go数据结构" tabindex="-1"><a class="header-anchor" href="#go数据结构" aria-hidden="true">#</a> go数据结构</h2><h4 id="切片和数组" tabindex="-1"><a class="header-anchor" href="#切片和数组" aria-hidden="true">#</a> 切片和数组</h4><p>slice的底层是数组，是对数组的封装，可以用于描述数组的一个片段，两者都可以用于描述。 数组是定长的，而切片则可以动态的扩容。 在存储上，数组是一片连续的内存，而slice实质上是一个结构体。他的结构如下：</p><div class="language-golang line-numbers-mode" data-ext="golang"><pre class="language-golang"><code>// runtime/slice.go
type slice struct {
	array unsafe.Pointer // 元素指针
	len   int // 长度 
	cap   int // 容量
}
</code></pre><div class="line-numbers" aria-hidden="true"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div><ul><li>切片的扩容 当我们向slice中追加了元素后，如果空间不足时就会引起扩容。 按照以往常见的说法，在golang1.18版本更新之前网上大多数的文章都是这样描述slice的扩容策略的：</li></ul><blockquote><p>当原 slice 容量小于 1024 的时候，新 slice 容量变成原来的 2 倍；原 slice 容量超过 1024，新 slice 容量变成原来的1.25倍。</p></blockquote><p>在1.18版本更新之后，slice的扩容策略变为了：</p><blockquote><p>当原slice容量(oldcap)小于256的时候，新slice(newcap)容量为原来的2倍；原slice容量超过256，新slice容量newcap = oldcap+(oldcap+3*256)/4</p></blockquote>`,8),u={href:"https://github.com/golang/go/blob/dev.boringcrypto.go1.18/src/runtime/slice.go#L166",target:"_blank",rel:"noopener noreferrer"},h={href:"https://github.com/golang/go/blob/master/src/runtime/slice.go#L157",target:"_blank",rel:"noopener noreferrer"},p=l(`<ul><li>切片作为函数参考</li></ul><blockquote><p>go中的所有函数传值，都是值传递，没有引用传递。即便是传递了参数指针时，也只是基于内存地址对原有的变量进行操作。</p></blockquote><p>slice作为函数参数传递时，都会是按照值传递复制这个数据。但由于slice本身会携带一个底层数组的指针，在直接操作slice中的变量，例如<code>slice[i] = 1</code>时，则会直接改变到原有的数组的值。</p><p>而如果我们对复制的值进行其他操作，如<code>append</code>时，则会生成一个新的slice，此时原有的数组则不会受到影响。</p><blockquote><p>推测：当我们对一个slice操作时，如果没有涉及到原有slice的扩容，是否也会影响到？</p></blockquote><h4 id="map" tabindex="-1"><a class="header-anchor" href="#map" aria-hidden="true">#</a> map</h4><ul><li>map的实现 go中map的底层是一个hmap</li></ul><div class="language-golang line-numbers-mode" data-ext="golang"><pre class="language-golang"><code>// A header for a Go map.
type hmap struct {
    // 元素个数，调用 len(map) 时，直接返回此值
	count     int
	flags     uint8
	// buckets 的对数 log_2
	B         uint8
	// overflow 的 bucket 近似数
	noverflow uint16
	// 计算 key 的哈希的时候会传入哈希函数
	hash0     uint32
    // 指向 buckets 数组，大小为 2^B
    // 如果元素个数为0，就为 nil
	buckets    unsafe.Pointer
	// 等量扩容的时候，buckets 长度和 oldbuckets 相等
	// 双倍扩容的时候，buckets 长度会是 oldbuckets 的两倍
	oldbuckets unsafe.Pointer
	// 指示扩容进度，小于此地址的 buckets 迁移完成
	nevacuate  uintptr
	extra *mapextra // optional fields
}
</code></pre><div class="line-numbers" aria-hidden="true"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div><p><img src="https://golang.design/go-questions/map/assets/0.png" alt="image" loading="lazy"></p><p>map的哈希函数：在程序启动时，会检测 cpu 是否支持 aes，如果支持，则使用 aes hash，否则使用 memhash。 map使用链地址法处理哈希冲突，因此当哈希碰撞发生时，map会最终退化成一个链表。</p><ul><li><p>map的遍历 map会在遍历开始时，生成随机树种子，随机的访问其中的一个bucket，另外由于map会有扩容搬迁过程，导致map的遍历是<strong>一定</strong>会无序的</p></li><li><p>map的赋值</p></li><li><p>map的扩容</p></li><li><p>map的key可以有哪些</p></li></ul><p>Go 语言中只要是可比较的类型都可以作为 key。除开 slice，map，functions 这几种类型，其他类型都是 OK 的。具体包括：布尔值、数字、字符串、指针、通道、接口类型、结构体、只包含上述类型的数组。 任何类型都可以作为 value，包括 map 类型。</p><ul><li><p>map的线程安全 map不是一个线程安全的结构，同时读写时会直接panic。 但如果在同一个协程内进行同时读写，不会被编译器检测到，但这是危险的操作。一般可以通过<code>sync.RWMutex</code>解决 <code>sync.Map</code>是线程安全的map，可以用来使用，但<code>sync.Map</code>没有<code>len</code>方法，需要自己遍历实现。</p></li><li><p>map 深度相等的条件：</p></li></ul><ol><li>都为 nil</li><li>非空、长度相等，指向同一个 map 实体对象</li><li>相应的 key 指向的 value “深度”相等</li></ol><h2 id="接口interface" tabindex="-1"><a class="header-anchor" href="#接口interface" aria-hidden="true">#</a> 接口Interface</h2><ul><li>接口</li></ul><p>接口支持鸭子类型<code>Duck Typing</code>。也就是编译器可以通过判断一个类型是否显式的实现了某一个接口。如果有，那么即便没有声明，也会被认为实现了该接口。</p><ul><li>接口的值接受者和指针接受者</li></ul><p>直接说结果：值接受者和指针接受者可以直接混用，这是编译器做了一些隐式转换。</p><table><thead><tr><th>-</th><th>值接收者</th><th>指针接收者</th></tr></thead><tbody><tr><td>值类型调用者</td><td>方法会使用调用者的一个副本，类似于“传值”</td><td>使用值的引用来调用方法</td></tr><tr><td>指针类型调用者</td><td>指针被解引用为值</td><td>实际上也是“传值”，方法里的操作会影响到调用者，类似于指针传参，拷贝了一份指针</td></tr></tbody></table><p>使用指针作为方法的接收者的理由：</p><ul><li>方法能够修改接收者指向的值。</li><li>避免在每次调用方法时复制该值，在值的类型为大型结构体时，这样做会更加高效。</li></ul><h2 id="channel" tabindex="-1"><a class="header-anchor" href="#channel" aria-hidden="true">#</a> Channel</h2><h2 id="go标准库" tabindex="-1"><a class="header-anchor" href="#go标准库" aria-hidden="true">#</a> go标准库</h2><h2 id="调度器" tabindex="-1"><a class="header-anchor" href="#调度器" aria-hidden="true">#</a> 调度器</h2><h2 id="gc" tabindex="-1"><a class="header-anchor" href="#gc" aria-hidden="true">#</a> GC</h2><h2 id="编译与运行" tabindex="-1"><a class="header-anchor" href="#编译与运行" aria-hidden="true">#</a> 编译与运行</h2><h4 id="go程序的运行过程" tabindex="-1"><a class="header-anchor" href="#go程序的运行过程" aria-hidden="true">#</a> go程序的运行过程</h4><h4 id="编译时的逃逸分析" tabindex="-1"><a class="header-anchor" href="#编译时的逃逸分析" aria-hidden="true">#</a> 编译时的逃逸分析</h4><h3 id="阅读" tabindex="-1"><a class="header-anchor" href="#阅读" aria-hidden="true">#</a> 阅读</h3>`,30),g={href:"https://golang.design/go-questions/",target:"_blank",rel:"noopener noreferrer"},m={href:"https://draveness.me/golang/",target:"_blank",rel:"noopener noreferrer"};function b(v,f){const i=d("ExternalLinkIcon");return t(),r("div",null,[o,e("p",null,[a("可以看到这是会按照版本动态变化的，扩容的实际实现位于src/runtime/slice.go中的growslice 。 1.18 版本的实现可以通过这里查看："),e("a",u,[a("https://github.com/golang/go/blob/dev.boringcrypto.go1.18/src/runtime/slice.go#L166"),n(i)]),a(" master分支的实现在这里："),e("a",h,[a("https://github.com/golang/go/blob/master/src/runtime/slice.go#L157"),n(i)]),a(" 按照饶大给出的分析，除了在按照规律扩容以外，还会进行内存对齐。")]),p,e("ul",null,[e("li",null,[e("p",null,[e("a",g,[a("Go 程序员面试笔试宝典"),n(i)])])]),e("li",null,[e("p",null,[e("a",m,[a("Go 语言设计与实现"),n(i)])])])])])}const x=s(c,[["render",b],["__file","golang.html.vue"]]);export{x as default};
